# Acceleration Council — Expansion Plan

**Goal:** Comprehensive coverage for ALL project types — no gaps.

**Current:** 84 execution skills + 5 councils + 12 workflows
**Target:** ~170 execution skills + 6 councils + 20 workflows

---

## Architecture: How Skills Work Together

### Problem
Skills are isolated markdown files. Without a system, they don't pass information to each other, don't know what was decided upstream, and can't research current APIs/versions.

### Solution: Three Protocols

Every skill includes three protocols that make the system cohesive:

#### 1. Handoff Protocol (skill → skill communication)

Skills read upstream decisions and write their own for downstream skills, through a shared workspace:

```
.claude/
├── context/                    # Generated by setup skill (project-level)
│   ├── product-context.md      # Business: ICP, positioning, value prop
│   ├── tech-context.md         # Stack, versions, constraints, team size
│   ├── finance-context.md      # Revenue model, funding stage, burn rate
│   └── legal-context.md        # Jurisdiction, entity type, compliance needs
│
├── outputs/                    # Each skill writes decisions here
│   ├── system-architecture.md  # → read by api-design, database-schema, auth-design
│   ├── database-schema.md      # → read by data-migration, auth-design, backend skills
│   ├── api-design.md           # → read by frontend skills, webhook-design, mobile
│   ├── auth-design.md          # → read by all skills that touch protected resources
│   ├── react-patterns.md       # → read by state-management, form-design, UI skills
│   ├── smart-contract-design.md # → read by security, gas-optimization, tokenomics
│   └── ...                     # Every executed skill writes here
│
└── versions.md                 # Verified library versions (updated by Research Protocol)
```

**Output format** (every skill writes this after execution):

```markdown
# [Skill Name] — Decisions

## Timestamp
[Date executed]

## Key Decisions
- [Decision]: [Choice] — [Rationale]

## Constraints for Downstream Skills
- [What downstream skills MUST respect from this decision]

## Interfaces Defined
- [APIs, schemas, contracts other skills should use]

## Open Questions
- [What needs answering by other skills]
```

**How it chains:** When you run `api-design`, it reads `system-architecture.md` outputs and designs APIs that fit the architecture. When `react-patterns` runs next, it reads `api-design.md` outputs and designs components that call those APIs. Each skill builds on what came before.

#### 2. Research Protocol (staying current)

Every skill mandates research BEFORE execution using tools built into Claude Code:

```markdown
## Research Protocol

Before executing this skill, verify current versions and best practices:

### Step 1: Web Search (always available in Claude Code)
Search for:
- "[Library] latest stable version [current year]"
- "[Library] breaking changes [latest major version]"
- "[Technology] best practices [current year]"

### Step 2: WebFetch official docs (for specific API verification)
Fetch canonical documentation URLs:
- [Skill lists 2-3 official doc URLs relevant to its domain]
- Example: https://react.dev/blog — for latest React changes
- Example: https://docs.soliditylang.org — for Solidity version

### Step 3: Update versions file
Write verified versions to `.claude/versions.md`:
  | Library | Version | Verified Date | Breaking Changes |
  |---------|---------|---------------|------------------|
  | React | 19.1.0 | 2026-02-17 | Server Components stable |
  | Next.js | 15.2.0 | 2026-02-17 | Turbopack default |

### Step 4 (Optional): Context7 MCP (if available)
If the user has Context7 MCP installed, use it for deeper queries:
- `mcp__context7__resolve-library-id` → resolve library
- `mcp__context7__query-docs` → fetch specific API docs

Note: Context7 is optional. Steps 1-3 work for everyone.
```

**Why this matters:** A `react-patterns` skill written in Feb 2026 might reference React 18 patterns. The Research Protocol forces Claude to check "is React 19 out? Did Server Components change?" before applying the skill's decision trees.

#### 3. Orchestrator Protocol (chaining skills for a task)

A meta-skill (`orchestrator`) reads the SKILL-MAP and determines execution order:

```
User says: "Build a full-stack AI-powered job matching feature"

Orchestrator determines:
1. Read SKILL-MAP.md dependency graph
2. Identify relevant skills:
   - system-architecture → database-schema → api-design
   - rag-architecture → embedding-strategy → vector-database
   - react-patterns → state-management → form-design
   - testing-strategy → ci-cd-pipeline
3. Resolve dependency order (topological sort)
4. Execute skills in order, each reading upstream outputs
5. Run appropriate council review at the end
```

The orchestrator is a skill itself (`setup/orchestrator/SKILL.md`) that:
- Takes a task description as input
- Maps it to relevant skills from SKILL-MAP
- Outputs an execution plan with order and dependencies
- Tracks which skills have been executed and their outputs

### How the Three Protocols Interact

```
┌─────────────┐
│ User Task    │ "Build a real-time chat feature"
└──────┬──────┘
       ▼
┌─────────────┐
│ Orchestrator │ Reads SKILL-MAP, determines:
│              │ real-time-architecture → api-design →
│              │ database-schema → react-patterns →
│              │ state-management → client-state-sync →
│              │ testing-strategy
└──────┬──────┘
       ▼
┌─────────────────────────────────────────────────┐
│ For each skill in order:                         │
│                                                  │
│  1. RESEARCH: WebSearch + WebFetch for latest     │
│     versions of relevant libraries               │
│                                                  │
│  2. READ: .claude/context/* (project context)    │
│          .claude/outputs/* (upstream decisions)   │
│          .claude/versions.md (verified versions)  │
│                                                  │
│  3. EXECUTE: Apply decision trees, generate       │
│     recommendations using current information     │
│                                                  │
│  4. WRITE: Output decisions to                    │
│     .claude/outputs/[skill-name].md              │
│                                                  │
│  5. NEXT: Move to next skill in chain            │
└─────────────────────────────────────────────────┘
       ▼
┌─────────────┐
│ Council      │ Review final outputs against rubrics
│ Review       │ (tech council for this example)
└─────────────┘
```

---

## Status

| Category | Existing | New | Total | Status |
|----------|----------|-----|-------|--------|
| Marketing | 25 | 0 | 25 | DONE |
| Finance | 13 | 0 | 13 | DONE |
| Legal | 13 | 0 | 13 | DONE |
| AI Governance | 12 | 0 | 12 | DONE |
| Tech / Core | 15 | 0 | 15 | DONE |
| Tech / Frontend | 0 | 12 | 12 | **12 WRITTEN** (just completed) |
| Tech / Backend | 0 | 12 | 12 | PLANNED |
| Tech / UI Engineering | 0 | 10 | 10 | PLANNED |
| Tech / AI Engineering | 0 | 12 | 12 | PLANNED |
| Tech / Blockchain & Web3 | 0 | 10 | 10 | PLANNED |
| Tech / Data Engineering | 0 | 8 | 8 | PLANNED |
| Tech / DevOps & Infrastructure | 0 | 8 | 8 | PLANNED |
| Tech / Mobile | 0 | 8 | 8 | PLANNED |
| Tech / Systems & Algorithms | 0 | 6 | 6 | PLANNED |
| **TOTAL** | **84** | **86** | **~170** | |

---

## Batch 1: Backend (12 skills) — PLANNED

| Skill | Purpose |
|-------|---------|
| `caching-strategy` | Redis, CDN, in-memory, cache invalidation patterns |
| `real-time-architecture` | WebSocket, SSE, polling, CRDT, presence |
| `file-storage-design` | Uploads, presigned URLs, CDN, image processing pipelines |
| `email-system` | Transactional, bulk, templates, deliverability, DKIM/SPF |
| `search-implementation` | Full-text, faceted, autocomplete, relevance tuning, Elasticsearch vs Postgres FTS |
| `notification-system` | Push, in-app, email, SMS, preference management, batching |
| `middleware-design` | Auth, logging, rate limiting, CORS, request validation chains |
| `rate-limiting` | Token bucket, sliding window, per-user/endpoint, distributed rate limiting |
| `queue-architecture` | Pub/sub vs point-to-point, ordering, dead letter, exactly-once delivery |
| `scheduled-tasks` | Cron patterns, distributed locks, idempotency, missed-run handling |
| `api-gateway` | Routing, load balancing, circuit breaker, request transformation |
| `graphql-design` | Schema design, N+1 (DataLoader), subscriptions, federation, persisted queries |

---

## Batch 2: UI Engineering (10 skills) — PLANNED

| Skill | Purpose |
|-------|---------|
| `design-system` | Tokens, components, documentation, versioning, Storybook |
| `component-architecture` | Composition, slots, polymorphism, headless patterns |
| `theming` | CSS variables, dark mode, brand customization, dynamic themes |
| `layout-patterns` | Grid systems, responsive containers, holy grail, sidebar layouts |
| `loading-states` | Skeletons, spinners, progressive disclosure, optimistic UI |
| `data-visualization` | Charts, dashboards, real-time updates, accessibility for viz |
| `table-design` | Sorting, filtering, pagination, virtual scroll, column resize, export |
| `navigation-patterns` | Sidebar, tabs, breadcrumbs, command palette, mobile nav |
| `modal-dialog-patterns` | Modals, drawers, sheets, confirmation dialogs, focus trapping |
| `drag-drop-design` | Sortable lists, kanban boards, file upload zones, accessibility |

---

## Batch 3: AI Engineering (12 skills) — PLANNED

| Skill | Purpose |
|-------|---------|
| `rag-architecture` | Retrieval-augmented generation: chunking, retrieval, reranking, hybrid search |
| `embedding-strategy` | Model selection, dimensionality, similarity metrics, batch vs real-time |
| `fine-tuning-strategy` | When to fine-tune vs prompt, data prep, evaluation, cost analysis |
| `agent-design` | Tool use, planning loops, memory, multi-agent orchestration, ReAct |
| `eval-pipeline` | LLM evaluation: benchmarks, human eval, automated scoring, regression testing |
| `prompt-management` | Versioning, A/B testing, templates, prompt registries |
| `vector-database` | pgvector vs Pinecone vs Weaviate, indexing, filtering, scaling |
| `llm-streaming` | SSE streaming, structured output parsing, token-by-token rendering |
| `tool-use-design` | Function calling schemas, error handling, permission scoping, tool chains |
| `ai-cost-optimization` | Model routing, semantic caching, batching, distillation, token budgets |
| `multimodal-design` | Vision, audio, document processing, combined modalities |
| `ai-safety-engineering` | Guardrails, content filtering, jailbreak prevention, output validation |

---

## Batch 4: Blockchain & Web3 (10 skills) — PLANNED

| Skill | Purpose |
|-------|---------|
| `smart-contract-design` | Patterns (proxy, factory, diamond), upgradability, state management |
| `smart-contract-security` | Reentrancy, overflow, access control, flash loan attacks, audit checklist |
| `tokenomics` | Token design, distribution schedules, vesting, utility vs governance |
| `wallet-integration` | Connect wallet UX, signing, transaction flow, multi-chain support |
| `gas-optimization` | Storage patterns, batch operations, calldata optimization, EIP-2929 |
| `defi-patterns` | AMM, lending pools, staking, yield farming, liquidation mechanics |
| `nft-architecture` | Metadata standards, royalties, marketplace integration, on-chain vs off-chain |
| `on-chain-data` | Indexing (subgraphs, Ponder), event processing, archive nodes |
| `cross-chain-design` | Bridges, messaging protocols, interoperability standards |
| `dao-governance` | Voting mechanisms, proposals, treasury management, delegation |

---

## Batch 5: Data Engineering (8 skills) — PLANNED

| Skill | Purpose |
|-------|---------|
| `data-modeling` | Star schema, snowflake, dimensional modeling, graph data models |
| `query-optimization` | EXPLAIN plans, index strategies, materialized views, query rewriting |
| `etl-pipeline` | Extract-transform-load, scheduling, monitoring, error handling, idempotency |
| `analytics-instrumentation` | Event taxonomy, properties, funnels, cohorts, user identification |
| `data-validation` | Schema validation, quality checks, anomaly detection, data contracts |
| `data-warehouse` | OLAP design, columnar storage, partitioning, incremental refresh |
| `streaming-data` | Kafka, event sourcing, CDC (Change Data Capture), real-time analytics |
| `data-privacy-engineering` | Anonymization, pseudonymization, retention policies, right-to-forget |

---

## Batch 6: DevOps & Infrastructure (8 skills) — PLANNED

| Skill | Purpose |
|-------|---------|
| `containerization` | Docker multi-stage builds, compose, orchestration, image optimization |
| `infrastructure-as-code` | Terraform, Pulumi, CloudFormation, state management, modules |
| `secrets-management` | Vault, AWS Secrets Manager, rotation, least privilege, env var hygiene |
| `scaling-strategy` | Horizontal/vertical, auto-scaling policies, capacity planning, load testing |
| `disaster-recovery` | Backup strategies, RTO/RPO, failover, chaos engineering, runbooks |
| `observability-platform` | Metrics pipeline, log aggregation, trace collection, correlation |
| `network-design` | VPC, DNS, CDN configuration, load balancing, WAF, DDoS protection |
| `cloud-cost-optimization` | Right-sizing, reserved instances, spot/preemptible, FinOps practices |

---

## Batch 7: Mobile (8 skills) — PLANNED

| Skill | Purpose |
|-------|---------|
| `mobile-architecture` | Native vs cross-platform decision, offline-first, navigation patterns |
| `react-native-patterns` | Navigation, native modules, performance, Expo vs bare workflow |
| `mobile-performance` | Startup time, memory management, battery optimization, network efficiency |
| `push-notification-design` | FCM/APNs integration, deep links, segmentation, preference management |
| `mobile-auth` | Biometrics, secure storage (Keychain/Keystore), token management |
| `app-store-optimization` | Metadata, screenshots, reviews, A/B testing, keyword strategy |
| `offline-first-design` | Sync strategies, conflict resolution, local storage, queue-and-sync |
| `mobile-testing` | Device matrix, screenshot testing, crash reporting, CI for mobile |

---

## Batch 8: Systems & Algorithms (6 skills) — PLANNED

| Skill | Purpose |
|-------|---------|
| `algorithm-selection` | Decision framework: time/space complexity, when to use which algorithm |
| `distributed-systems` | CAP theorem, consensus, eventual consistency, partition tolerance |
| `concurrency-patterns` | Locks, queues, actors, CSP, async patterns, race condition prevention |
| `data-structure-selection` | When hash map vs tree vs graph vs trie vs bloom filter |
| `protocol-design` | REST vs gRPC vs GraphQL vs WebSocket — decision framework with trade-offs |
| `compiler-interpreter-design` | Lexing, parsing, AST, code generation — for DSLs and config languages |

---

## Execution Order

1. **Backend** (12) — most commonly needed alongside frontend
2. **UI Engineering** (10) — completes the frontend/UI stack
3. **AI Engineering** (12) — hot domain, lots of bad patterns
4. **Blockchain** (10) — specialized but comprehensive
5. **Data Engineering** (8) — analytics/data layer
6. **DevOps** (8) — infrastructure layer
7. **Mobile** (8) — separate platform concerns
8. **Systems** (6) — advanced/foundational

**After all batches:**
- Update SKILL-MAP.md with new skills and dependencies
- Add new workflow recipes for new skill combinations
- Update README.md with final counts
- Git commit and push to yogi100x/claude-skills

---

## New Workflow Recipes to Add

| Recipe | Skills Chained |
|--------|---------------|
| **Full-Stack Feature** | `database-schema` → `api-design` → `react-patterns` → `state-management` → `form-design` → `testing-strategy` |
| **AI Feature (RAG)** | `rag-architecture` → `embedding-strategy` → `vector-database` → `prompt-management` → `llm-streaming` → `eval-pipeline` |
| **DeFi Protocol** | `smart-contract-design` → `tokenomics` → `smart-contract-security` → `gas-optimization` → `wallet-integration` |
| **Mobile App Launch** | `mobile-architecture` → `react-native-patterns` → `mobile-auth` → `push-notification-design` → `offline-first-design` → `app-store-optimization` |
| **Data Platform** | `data-modeling` → `etl-pipeline` → `data-warehouse` → `analytics-instrumentation` → `data-visualization` |
| **Design System** | `design-system` → `component-architecture` → `theming` → `layout-patterns` → `accessibility` → `documentation` |
| **Real-Time Feature** | `real-time-architecture` → `queue-architecture` → `client-state-sync` → `notification-system` |
| **Infrastructure Setup** | `containerization` → `infrastructure-as-code` → `secrets-management` → `network-design` → `scaling-strategy` → `disaster-recovery` |

---

## Councils Update

Add a 6th council: **`council-blockchain`** with:
- Smart Contract Auditor
- Tokenomics Reviewer
- DeFi Security Specialist
- Gas Optimization Expert
- UX Researcher (Web3 UX)

---

## Infrastructure Tasks (before writing new skills)

### Task 0a: Create Orchestrator Skill
Write `setup/orchestrator/SKILL.md` — the meta-skill that:
- Reads a task description
- Maps to relevant skills from SKILL-MAP
- Resolves dependency order
- Outputs execution plan
- Tracks progress through skill chain

### Task 0b: Create Skill Template with All Three Protocols
Create `shared/SKILL-TEMPLATE.md` — the template every new skill must follow:

```markdown
---
name: [skill-name]
version: 2.0.0
category: [category]
description: "[trigger description]"
---

# [Skill Title]

[Expert persona]

---

## Research Protocol

Before executing, verify current state:

### Web Search (required)
- "[Specific search 1]"
- "[Specific search 2]"

### WebFetch (canonical docs)
- [URL 1]
- [URL 2]

### Update `.claude/versions.md`
[Libraries this skill uses]

---

## Context Sync Protocol

### Read Context (required)
- `.claude/context/[relevant]-context.md`

### Read Upstream Outputs (if they exist)
- `.claude/outputs/[upstream-skill].md` — [what to look for]

---

## [Skill Content — Decision Trees, Patterns, etc.]

---

## Anti-Pattern References
[Coded IDs linking to shared/references/anti-patterns.md]

## Quality Rubric (35 points)
[7 dimensions × 5 points]

## Cross-Skill References
- **Upstream:** [skills that feed into this one]
- **Downstream:** [skills that read this one's output]
- **Council:** [which council reviews this skill's output]

---

## Output Protocol (required after execution)

Write to `.claude/outputs/[this-skill-name].md`:
- Key decisions made
- Constraints for downstream skills
- Interfaces defined
- Open questions
```

### Task 0c: Retrofit Existing 84 Skills
Add Research Protocol and Output Protocol to all existing skills.
(Can be done after new skills are written — batch retrofit.)

### Task 0d: Update SKILL-MAP.md
Add all new skills with full dependency graph showing:
- Which skills read which outputs
- Research URLs per skill
- Council assignment per skill

---

## Full Execution Order

1. **Task 0a-0d**: Infrastructure (orchestrator, template, SKILL-MAP update)
2. **Batch 1**: Backend (12 skills)
3. **Batch 2**: UI Engineering (10 skills)
4. **Batch 3**: AI Engineering (12 skills)
5. **Batch 4**: Blockchain & Web3 (10 skills)
6. **Batch 5**: Data Engineering (8 skills)
7. **Batch 6**: DevOps & Infrastructure (8 skills)
8. **Batch 7**: Mobile (8 skills)
9. **Batch 8**: Systems & Algorithms (6 skills)
10. **Task 0c**: Retrofit existing 84 skills with new protocols
11. **New workflows**: Add 8 new workflow recipes
12. **Council**: Add `council-blockchain`
13. **Publish**: Update README, commit, push to GitHub

**Estimated total new skills: 86 + orchestrator + template = 88 new files**
**Retrofit: 84 existing skills updated**
**Final total: ~172 execution skills, 6 councils, 20 workflows**
